---
Author:
  - Xinyang YU
Author Profile:
  - https://linkedin.com/in/xinyang-yu
tags:
  - OS
Creation Date: 2023-11-29T19:10:00
Last Date: 2024-03-27T20:58:22+08:00
References: 
sr-due: 2024-03-01
sr-interval: 8
sr-ease: 267
---
## Interrupt
---
- When an interrupt occurs, [[Control Unit#Program Counter]] jumps to [[Interrupt Handler]] & execute 


**Mechanism**
1. Causes [[Process (进程)]] to temporarily suspend
2. Save the state info of the process into the corresponding [[Process Control Block (PCB)]]
3. Executes the [[Interrupt Handler]]
4. When Interrupt Handler is done, the running [[Process (进程)]] is restarted and the state is restored from the PCB

>[!success] Free the CPU, no more Polling
> We don't need to get [[CPU]] to keep **Polling** for response which may take a long time to produce. Instead, send a notification to the CPU via interrupt. Thus, CPU is able to do other stuff while waiting for a response 


>[!caution] Generally can't be interrupted
> Interrupts are allowed to run to completion without being interrupted by other sources. For example, if a keyboard's interrupt is interrupted, we may lose the input from the keyboard
> 
> However, there are exceptions (This part I haven't explored yet)

>[!caution] Busy State
> As long as the [[Interrupt Handler]] is running, other interrupts may not be handled, and interrupts are generally not queued
> 
> But [[Interrupt Priorities]] exist in some systems to handle **Simultaneous Interrupts**

>[!tip]
>Interrupts should complete quickly to prevent the above problems





## Software Interrupt
---
- Follow the [[Sequential Circuit#Synchronous Sequential Circuit]] behaviour
- Request a **service** or **privileged operations** ([[System Call (系统调用)]]) from the [[Kernel]]

>[!success] Syscall brings Better Security
> Programs in [[User Space]] switching [[Privilege Level]] themselves is dangerous. With Software Interrupt, the [[CPU]] is preconfigured by Kernel with where in the kernel code to jump to

>[!example] Trap Interrupt
> Used to switch from [[Privilege Level#User Mode]] to [[Privilege Level#Kernel Mode]]. See [[Trap Interrupt (陷入)]] for more details.


## Upcall
---
![[software_interrupt.png|300]]
- Known as **Signal** in [[Unix#Unix-like]], or **Asynchronous Events** in **Windows**
- Follow the [[Sequential Circuit#Asynchronous Sequential Circuit]] behaviour, can occur at any time
- [[Process (进程)]] can be told by [[Kernel]] when some event that **deserves immediate attention** has occurred. This helps to virtualise some part of the Kernel, so that applications can behave more like kernel - handling [[#Hardware interrupts (外中断)]]
- Primarily focused on [[Inter-Process Communication (IPC)]] and **event handling** within a process

>[!example]
> **Generated by the kernel itself** 
> - [[Async IO]] notification
> - Logout — to notify applications that they should save file data and cleanly terminate
> - Resource adjustment - Java process can adapt to different amounts of available memory by changing the frequency of how often it runs its [[Garbage Collector]]. The more memory, the less time
> 
> **Generated by another process**
> - Termination signal – `SIGKILL`

>[!success] Asynchronous I/O notification
> A separate notification sent via an upcall to the application when the I/O completes. This eliminates waiting (idle) process that waits for IO [[System Call (系统调用)]] to complete!
## Hardware interrupts (外中断)
---
- Raised by hardware devices. Follow the [[Sequential Circuit#Asynchronous Sequential Circuit]] behaviour, can occur at any time
- One example is [[Timer Chip]] used for [[Multi-tasking#Preemptive Multitasking]]
- We have a [[Interrupt Controller]] like the [[RISCV CLINT]] in RISCV to handle interrupt sources that share the same **interrupt pin**

>[!example]- Alarm Signal
> Sent after a specified number of seconds has elapsed to notify a process of an **event**

>[!example]- Turn off interrupt in XV6-RISCV
> This is achieved by writing to the [[Register#Control & Status Registers (CSRs)]] - `sstatus`. The code snippets below going down the [[Abstraction (抽象)]] 
> 
> `intr_off()` is the entry point
> ```c {8} title="spinlock.c"
> // XV6-RISCV kernel codes, spinlock.c
> 
> // ...
> void
> push_off(void)
> {
>   // ..
>   intr_off();
>   // ...
> }
> // ...
> ```
> 
> We can see from code snippet below, to disable the **interrupt** is setting the second bit from right on the `sstatus` register
> ```c {11} title="riscv.h"
> // XV6-RISCV kernel codes, riscv.h
> 
> // ...
> #define SSTATUS_SIE (1L << 1) // Supervisor Interrupt Enable
> 
> // ...
> // disable device interrupts
> static inline void
> intr_off()
> {
>   w_sstatus(r_sstatus() & ~SSTATUS_SIE);
> }
> // ...
> ```
> 
> Eventually, it boils down to [[Assembly language]]
> ```c {7} title="riscv.h"
> // XV6-RISCV kernel codes, riscv.h
> 
> // ...
> static inline void 
> w_sstatus(uint64 x)
> {
>   asm volatile("csrw sstatus, %0" : : "r" (x));
> }
> // ..
> ```